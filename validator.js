// Generated by LiveScript 1.5.0
(function(){
  var registry, p, getType, toString$ = {}.toString;
  registry = require('./registry.js');
  p = require('prelude-ls');
  getType = function(obj){
    return (function(){
      switch (toString$.call(obj).slice(8, -1)) {
      case 'Object':
        return 'Complex';
      case 'Undefined':
        return 'Global.Undefined';
      case 'Null':
        return 'Global.Null';
      case 'String':
        return 'RegularExpression';
      case 'Boolean':
        return 'Global.Boolean';
      case 'Number':
        return 'Global.Number';
      case 'Array':
        return 'ArrayType';
      }
    }());
  };
  module.exports = function(typedef){
    var types, findType, lookupType, lookupInvokeFunctionType, lookupDiscriminationType, getExpectedTypes, validateComplexType, compile, validateValue, validateExpression, validateType, validate;
    types = registry.compile(typedef);
    findType = function(typename){
      var type;
      type = types[typename];
      if (types[typename] == null) {
        return "Type " + typename + " is not found";
      }
      return type;
    };
    lookupType = function(type){
      var found;
      found = findType(type.body);
      return getExpectedTypes(found);
    };
    lookupInvokeFunctionType = function(type){
      var newType;
      newType = {
        type: 'Internal.Extended',
        basetype: findType(type.body[0]),
        extensions: p.tail(
        type.body)
      };
      return [newType];
    };
    lookupDiscriminationType = function(type){
      return p.concat(
      p.map(getExpectedTypes)(
      type.body));
    };
    getExpectedTypes = function(type){
      switch (type.type) {
      case 'Type':
        return lookupType(type);
      case 'InvokeFunction':
        return lookupInvokeFunctionType(type);
      case 'Discrimination':
        return lookupDiscriminationType(type);
      default:
        return [type];
      }
    };
    validateComplexType = function(type, obj){
      var validate, result;
      validate = function(field){
        var result;
        result = validateType(field.body, obj[field.name]);
        switch (toString$.call(result).slice(8, -1)) {
        case 'String':
          return "'Field " + field.name + "': { " + result + " }";
        default:
          return result;
        }
      };
      result = p.map(validate)(
      type.fields);
      if (result.filter(function(it){
        return it === true;
      }).length === result.length) {
        return true;
      }
      return "{ " + result.filter(function(it){
        return it !== true;
      }).join(", ") + " }";
    };
    compile = function(str){
      var mask;
      mask = str.match("/(.+)/([ig]?)");
      return new RegExp(mask[1], mask[2]);
    };
    validateValue = curry$(function(obj, type){
      var objType, result, ref$, arrayType, items;
      objType = getType(obj);
      switch (type.type) {
      case 'Internal.Extended':
        return validateValue(obj, type.basetype);
      case 'String':
        result = type.body.indexOf(obj) > -1;
        if (result === true) {
          return true;
        }
        return "'" + obj + "' is not '" + type.body + "'";
      case 'RegularExpression':
        result = (ref$ = obj != null ? typeof obj.match == 'function' ? obj.match(compile(type.body)) : void 8 : void 8) != null ? ref$ : null;
        if (result != null) {
          return true;
        }
        return obj + " does not match to regular expression " + type.body;
      case 'ExportType':
        result = objType === type.body;
        if (result === true) {
          return true;
        }
        return "Type '" + getType(obj) + " isnt " + type.body + "'";
      case 'ArrayType':
        if (objType !== 'ArrayType') {
          return "Object Type is not And ArrayType";
        }
        arrayType = findType(type.body);
        switch (toString$.call(arrayType).slice(8, -1)) {
        case 'String':
          return arrayType;
        default:
          items = obj.map(function(it){
            return validateExpression(arrayType, it);
          });
          if (items.length === items.filter(function(it){
            return it === true;
          }).length) {
            return true;
          }
          return items.filter(function(it){
            return it === false;
          }).join("; ");
        }
        break;
      default:
        return type.type;
      }
    });
    validateExpression = function(type, obj){
      var types, result;
      types = getExpectedTypes(type);
      result = types.map(validateValue(obj));
      switch (false) {
      case !(type.type === 'Discrimination' && result.filter(function(it){
        return it === true;
      }).length > 0):
        return true;
      case result.filter(function(it){
          return it === true;
        }).length !== result.length:
        return true;
      default:
        return result.filter(function(it){
          return it !== true;
        }).join("; ");
      }
    };
    validateType = function(type, obj){
      switch (getType(obj)) {
      case 'Complex':
        return validateComplexType(type, obj);
      default:
        return validateExpression(type, obj);
      }
    };
    validate = function(typename, obj){
      var type;
      type = findType(typename);
      switch (toString$.call(type).slice(8, -1)) {
      case 'String':
        return type;
      default:
        return validateType(type, obj);
      }
    };
    return validate;
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
