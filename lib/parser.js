// Generated by LiveScript 1.5.0
var p, pattern, functionParams, bodyPattern, readDiscrimination, invokeFunction, tokenizeBody, readBody, tokenize, naming, read, checkers, parse, beautify, compile, transformValueField, transformValueFields, transformValue, compare, materializeType, registry, validate, register, toString$ = {}.toString;
p = {
  tail: function(xs){
    if (!xs.length) {
      return;
    }
    return xs.slice(1);
  }
};
module.exports = (pattern = /^(#.+)|^(([A-Z][_a-zA-Z0-9]+)(\s[a-z][a-zA-Z0-9]+)+\s+:\s+(.+))$|^(([A-Z][_a-zA-Z0-9]+)\s+:\s+(.+))$|^(([a-z_][_a-zA-Z0-9]+)\s+\:\s+(.+))$|^(-{3,})$|^(([A-Z][_a-zA-Z0-9]+)\.{3})$|^(([A-Z][_a-zA-Z0-9]+))$/, functionParams = function(str){
  return str.match(/[A-Z][_a-zA-Z0-9]+\s([^:]+)/)[1].trim().split(/\s+/);
}, bodyPattern = /(\/.+)|([^\|]+\|.+)|.+([A-Z][_a-zA-Z0-9]+\([^(]+\))|(\[[A-Z][_a-zA-Z0-9.]+\])|(\@.+)|(\"[^"]+\")|(-?[0-9]+)|([A-Z][_a-zA-Z0-9]+\.[A-Z][_a-zA-Z0-9]+)|([A-Z][_a-zA-Z0-9]+)/, readDiscrimination = function(str){
  return str.split(/\s\|\s/).map(readBody);
}, invokeFunction = function(str){
  return str.split(" ");
}, tokenizeBody = function(input){
  var res;
  if (toString$.call(input).slice(8, -1) !== 'Array') {
    return [];
  }
  res = (function(){
    switch (false) {
    case input[1] == null:
      return {
        type: 'RegularExpression',
        body: input[0]
      };
    case input[2] == null:
      return {
        type: 'Discrimination',
        body: readDiscrimination(input[0])
      };
    case input[3] == null:
      return {
        type: 'InvokeFunction',
        body: invokeFunction(input[0])
      };
    case input[4] == null:
      return {
        type: 'ArrayType',
        body: input[0].substr(1, input[0].length - 2)
      };
    case input[5] == null:
      return {
        type: 'OperationWithValue',
        body: input[0].replace(/\@/, 'this')
      };
    case input[6] == null:
      return {
        type: 'String',
        body: input[0].substr(1, input[0].length - 2)
      };
    case input[7] == null:
      return {
        type: 'Integer',
        body: input[0]
      };
    case input[8] == null:
      return {
        type: 'ExportType',
        body: input[0]
      };
    case input[9] == null:
      return {
        type: 'Type',
        body: input[0]
      };
    default:
      return {
        type: 'Error'
      };
    }
  }());
  res.origin = input[0];
  return res;
}, readBody = function(str){
  return tokenizeBody(str.match(bodyPattern));
}, tokenize = function(input){
  var res;
  if (toString$.call(input).slice(8, -1) !== 'Array') {
    return [];
  }
  res = (function(){
    switch (false) {
    case input[1] == null:
      return {
        type: 'Comment'
      };
    case input[2] == null:
      return {
        type: 'Function',
        name: input[3],
        body: readBody(input[5]),
        params: functionParams(input[0])
      };
    case input[6] == null:
      return {
        type: 'Type',
        name: input[7],
        body: readBody(input[8])
      };
    case input[9] == null:
      return {
        type: 'Field',
        name: input[10],
        body: readBody(input[11])
      };
    case input[12] == null:
      return {
        type: 'FieldStart'
      };
    case input[13] == null:
      return {
        type: 'TypeExtension',
        name: input[14]
      };
    case input[15] == null:
      return {
        type: 'ComplexType',
        name: input[15]
      };
    default:
      return {
        type: 'Error'
      };
    }
  }());
  res.origin = input[0];
  return [res];
}, naming = function(input){
  var tail;
  if (toString$.call(input).slice(8, -1) !== 'Array') {
    return input;
  }
  if (input.length === 0) {
    return [];
  }
  tail = p.tail(input);
  return tokenize(input[0]).concat(naming(tail));
}, read = function(input){
  var result, next;
  if (toString$.call(input).slice(8, -1) === 'Uint8Array') {
    return read(input.toString('utf8'));
  }
  if (toString$.call(input).slice(8, -1) === 'String') {
    return read(input.split('\n'));
  }
  if (toString$.call(input).slice(8, -1) !== 'Array') {
    return "Reading error: " + toString$.call(input).slice(8, -1) + " is not supported";
  }
  if (input.length === 0) {
    return [];
  }
  result = (function(){
    switch (false) {
    case input[0].length !== 0:
      return "";
    default:
      return input[0].match(pattern);
    }
  }());
  if (toString$.call(result).slice(8, -1) === 'Null') {
    return "Syntax Error: Unexpected Token on '" + input[0] + "'";
  }
  next = read(p.tail(input));
  if (toString$.call(next).slice(8, -1) === 'String') {
    return next;
  }
  return [result].concat(next);
}, checkers = [
  {
    curr: 'Field',
    after: ['FieldStart', 'Field'],
    otherwise: "Error: Field can go only after '----' FieldStart or Previous Field"
  }, {
    curr: 'FieldStart',
    after: ['ComplexType'],
    otherwise: "Error: FieldStart '----' can go only after ComplexType declaration statement"
  }, {
    curr: 'Function',
    after: ['Function', 'TypeExtension'],
    otherwise: "Error: Function '----' can go only after Type... extension or Previous Function"
  }
], parse = curry$(function(registry, lines){
  var curr, last, ref$, i$, len$, checker;
  if (toString$.call(lines).slice(8, -1) !== 'Array') {
    return lines;
  }
  if (lines.length === 0) {
    return registry;
  }
  curr = lines[0];
  if (toString$.call(curr).slice(8, -1) === 'String') {
    return curr;
  }
  last = (ref$ = registry[registry.length - 1]) != null
    ? ref$
    : {};
  for (i$ = 0, len$ = (ref$ = checkers).length; i$ < len$; ++i$) {
    checker = ref$[i$];
    if (checker.curr === curr.type && checker.after.indexOf(last.type) === -1) {
      registry.push(checker.otherwise);
      return registry;
    }
  }
  switch (curr.type) {
  case 'ComplexType':
    curr.fields = [];
    registry.push(curr);
    break;
  case 'FieldStart':
    last.type = 'FieldStart';
    break;
  case 'Field':
    last.fields.push(curr);
    break;
  case 'TypeExtension':
    curr.functions = [];
    registry.push(curr);
    break;
  case 'Function':
    last.functions.push(curr);
    break;
  case 'Type':
    registry.push(curr);
  }
  return parse(registry, p.tail(lines));
}), beautify = function(items){
  var types, register;
  if (toString$.call(items).slice(8, -1) !== 'Array') {
    return items;
  }
  types = {};
  register = function(item){
    var getType, type;
    getType = function(){
      var ref$;
      return types[item.name] = (ref$ = types[item.name]) != null
        ? ref$
        : {};
    };
    switch (item.type) {
    case 'Type':
      type = getType();
      type.type = item.body.type;
      return type.body = item.body.body;
    case 'TypeExtension':
      type = getType();
      return type.extensions = item.functions;
    case 'FieldStart':
      type = getType();
      type.type = 'Complex';
      return type.fields = item.fields;
    }
  };
  items.forEach(register);
  return types;
}, compile = function(example){
  return beautify(
  parse([])(
  naming(
  read(
  example))));
}, transformValueField = function(field){
  return {
    type: 'Field',
    name: field[0],
    body: transformValue(field[1])
  };
}, transformValueFields = function(fields){
  return map(transformObjField)(
  fields);
}, transformValue = function(o){
  switch (toString$.call(o).slice(8, -1)) {
  case 'Object':
    return {
      type: 'Complex',
      fields: transformValueFields(objToPairs(o))
    };
  case 'String':
    return {
      type: 'RegexExpression',
      body: o
    };
  case 'Number':
    return {
      type: 'Global.Number',
      body: o
    };
  case 'Boolean':
    return {
      type: 'Global.Boolean',
      body: o
    };
  case 'Function':
    return {
      type: 'Global.Function',
      body: o
    };
  case 'Undefined':
    return {
      type: 'Global.Undefined',
      body: o
    };
  case 'Null':
    return {
      type: 'Global.Null',
      body: o
    };
  default:
    return {
      type: 'Global.Unknown',
      body: o
    };
  }
}, compare = function(type, transformed){
  return "";
}, materializeType = function(type){
  return type;
}, registry = {}, validate = function(value, key){
  var pair, type, ref$, materialized, transformed;
  pair = key.split('.');
  type = (ref$ = registry[pair[0]]) != null ? ref$[pair[1]] : void 8;
  if (type == null) {
    return "Type " + key + " is not Declared";
  }
  materialized = materializeType(value);
  transformed = transformValue(value);
  return compare(materialized, transformed);
}, register = function(name, code){
  return registry[name] = compile(code);
}, {
  validate: validate,
  register: register,
  compile: compile
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}