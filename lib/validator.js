// Generated by LiveScript 1.5.0
var parser, p, compile, getType, toString$ = {}.toString;
parser = require('./parser.js');
p = {
  objToPairs: function(object){
    var key, value, results$ = [];
    for (key in object) {
      value = object[key];
      results$.push([key, value]);
    }
    return results$;
  },
  pairsToObj: function(object){
    var i$, len$, x, resultObj$ = {};
    for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
      x = object[i$];
      resultObj$[x[0]] = x[1];
    }
    return resultObj$;
  },
  map: curry$(function(f, xs){
    var i$, len$, x, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      results$.push(f(x));
    }
    return results$;
  }),
  tail: function(xs){
    if (!xs.length) {
      return;
    }
    return xs.slice(1);
  },
  concat: function(xss){
    return [].concat.apply([], xss);
  },
  filter: curry$(function(f, xs){
    return xs.filter(f);
  })
};
compile = function(str){
  var mask;
  mask = str.match("/(.+)/([ig]?)");
  return new RegExp(mask[1], mask[2]);
};
getType = function(obj){
  return (function(){
    switch (toString$.call(obj).slice(8, -1)) {
    case 'Object':
      return 'Complex';
    case 'Undefined':
      return 'Global.Undefined';
    case 'Null':
      return 'Global.Null';
    case 'String':
      return 'RegularExpression';
    case 'Boolean':
      return 'Global.Boolean';
    case 'Number':
      return 'Global.Number';
    case 'Array':
      return 'ArrayType';
    }
  }());
};
module.exports = function(source){
  var registry, findType, lookupType, findTypeByPair, lookupInvokeFunctionType, lookupDiscriminationType, getExpectedTypes, validateComplexType, parseInvoke, invokeRegularExpression, invokeOperationWithValue, invokeFunction, validateValue, validateExpression, validateType, validate;
  registry = p.pairsToObj(
  p.map(function(it){
    return [it[0], parser.compile(it[1])];
  })(
  p.objToPairs(
  source)));
  findType = function(scope, typename){
    var bundle_o, type;
    bundle_o = registry[scope];
    if (toString$.call(bundle_o).slice(8, -1) === 'String') {
      return bundle_o;
    }
    if (bundle_o == null) {
      return "Scope '" + scope + "' not found";
    }
    type = bundle_o[typename];
    if (type == null) {
      return "Type '" + typename + "' is not found in scope '" + scope + "'";
    }
    return type;
  };
  lookupType = function(scope, type){
    var found;
    found = findType(scope, type.body);
    return getExpectedTypes(scope, found);
  };
  findTypeByPair = function(pair){
    var items;
    items = pair.split('.');
    return {
      type: findType(items[0], items[1]),
      scope: items[0]
    };
  };
  lookupInvokeFunctionType = function(scope, type){
    var newType;
    newType = {
      type: 'Internal.Extended',
      basetype: (function(){
        switch (false) {
        case !(type.body[0].indexOf('.') > -1):
          return findTypeByPair(type.body[0]).type;
        default:
          return findType(scope, type.body[0]);
        }
      }()),
      extensions: p.tail(
      type.body)
    };
    return [newType];
  };
  lookupDiscriminationType = function(scope, type){
    return p.concat(
    p.map(getExpectedTypes(scope))(
    type.body));
  };
  getExpectedTypes = curry$(function(scope, type){
    switch (type.type) {
    case 'Type':
      return lookupType(scope, type);
    case 'InvokeFunction':
      return lookupInvokeFunctionType(scope, type);
    case 'Discrimination':
      return lookupDiscriminationType(scope, type);
    default:
      return [type];
    }
  });
  validateComplexType = function(scope, type, obj){
    var found, currentType, validate, result;
    if (type.type !== 'Complex' && type.body.indexOf('.') > -1) {
      found = findTypeByPair(type.body);
      return validateComplexType(found.scope, found.type, obj);
    }
    currentType = (function(){
      switch (false) {
      case type.type !== 'Complex':
        return type;
      default:
        return findType(scope, type.body);
      }
    }());
    if (currentType.type !== 'Complex') {
      return "{Type " + type.body + " isnt complex}";
    }
    validate = function(field){
      var result;
      result = validateType(scope, field.body, obj[field.name]);
      switch (toString$.call(result).slice(8, -1)) {
      case 'String':
        return "'Field " + field.name + "': { " + result + " }";
      default:
        return result;
      }
    };
    result = p.map(validate)(
    currentType.fields);
    if (result.filter(function(it){
      return it === true;
    }).length === result.length) {
      return true;
    }
    return "{ " + result.filter(function(it){
      return it !== true;
    }).join(", ") + " }";
  };
  parseInvoke = function(expression){
    var parsed, ref$, ref1$;
    parsed = expression.match(/([A-Z][a-z0-9]+)\(([^\)]+)\)/);
    return {
      name: parsed != null ? parsed[1] : void 8,
      params: (ref$ = parsed != null ? (ref1$ = parsed[2]) != null ? typeof ref1$.split == 'function' ? ref1$.split(",") : void 8 : void 8 : void 8) != null
        ? ref$
        : []
    };
  };
  invokeRegularExpression = function(body, params, obj){
    var state, replace, result;
    if (toString$.call(obj).slice(8, -1) !== 'String') {
      return "Object should have type Global.String";
    }
    state = {
      str: body.body
    };
    replace = function(param){
      var find;
      find = new RegExp("#{" + param.name + "}");
      return state.str = state.str.replace(find, param.value);
    };
    params.forEach(replace);
    result = obj.match(compile(state.str));
    if (result != null) {
      return true;
    }
    return "'" + obj + "' does not match to " + state.str;
  };
  invokeOperationWithValue = function(body, params, obj){
    var state, err, ref$, result, paramsStr;
    state = {
      func: null
    };
    if (body.body.substr(0, 4) !== 'this') {
      return "Body expected started with 'this'. Actual value is '" + body.body.substr(0, 4) + "' in '" + body.body + "'";
    }
    try {
      state.func = eval("test = function (" + params.map(function(it){
        return it.name;
      }).join(',') + ") { return " + body.body + " }");
    } catch (e$) {
      err = e$;
      return "Syntax error in " + body.body + " : " + ((ref$ = err.message) != null ? ref$ : err);
    }
    result = state.func.apply(obj, params.map(function(it){
      return it.value;
    }));
    if (result === true) {
      return true;
    }
    paramsStr = params.map(function(it){
      return "'" + it.name + "' = '" + it.value + "'";
    }).join(", ");
    return "'" + obj + "' does not pass the condition '" + body.body + "' with params " + paramsStr;
  };
  invokeFunction = function(func, params, obj){
    switch (func.body.type) {
    case "RegularExpression":
      return invokeRegularExpression(func.body, params, obj);
    case "OperationWithValue":
      return invokeOperationWithValue(func.body, params, obj);
    default:
      return "Function " + func.body.type + " is not supported";
    }
  };
  validateValue = curry$(function(scope, obj, type){
    var objType, result, apply, ref$, parts, processArrayType, found, arrayType;
    objType = getType(obj);
    switch (type.type) {
    case 'Internal.Extended':
      result = validateValue(scope, obj, type.basetype);
      if (result !== true) {
        return result;
      }
      apply = function(invoke){
        var basetype, func, appliedParams, applyParam;
        basetype = (function(){
          switch (false) {
          case !(type.basetype.type === 'ExportType' && type.basetype.extensions == null):
            return findTypeByPair(type.basetype.body).type;
          default:
            return type.basetype;
          }
        }());
        if (basetype.extensions == null) {
          return "BaseType doesn't have extensions";
        }
        func = basetype.extensions.filter(function(it){
          return it.name === invoke.name;
        })[0];
        if (func == null) {
          return "Function " + invoke.name + " is not found";
        }
        appliedParams = [];
        applyParam = function(param, index){
          return appliedParams.push({
            name: param,
            value: invoke.params[index]
          });
        };
        func.params.forEach(applyParam);
        return invokeFunction(func, appliedParams, obj);
      };
      result = type.extensions.map(parseInvoke).map(apply);
      if (result.filter(function(it){
        return it === true;
      }).length === result.length) {
        return true;
      }
      return result.filter(function(it){
        return it !== true;
      }).join("; ");
    case 'String':
      result = type.body.indexOf(obj) > -1;
      if (result === true) {
        return true;
      }
      return "'" + obj + "' is not '" + type.body + "'";
    case 'RegularExpression':
      if (toString$.call(obj).slice(8, -1) !== 'String') {
        return "Type of " + obj + " is " + toString$.call(obj).slice(8, -1) + " but expected a String";
      }
      result = (ref$ = obj != null ? typeof obj.match == 'function' ? obj.match(compile(type.body)) : void 8 : void 8) != null ? ref$ : null;
      if (result != null) {
        return true;
      }
      return "'" + obj + "' does not match to regular expression " + type.body;
    case 'ExportType':
      parts = type.body.split('.');
      switch (false) {
      case parts.length === 2:
        return "Export Type " + type.body + " is not valid";
      case parts[0] !== 'Global':
        result = objType === type.body;
        if (result === true) {
          return true;
        }
        return "Type '" + objType + " isnt " + type.body + "'";
      default:
        return validate(type.body, obj);
      }
      break;
    case 'ArrayType':
      if (objType !== 'ArrayType') {
        return "Object Type is not And ArrayType";
      }
      processArrayType = function(scope, arrayType){
        var items;
        switch (toString$.call(arrayType).slice(8, -1)) {
        case 'String':
          return arrayType;
        default:
          items = obj.map(function(it){
            return validateExpression(scope, arrayType, it);
          });
          if (items.length === items.filter(function(it){
            return it === true;
          }).length) {
            return true;
          }
          return items.filter(function(it){
            return it === false;
          }).join("; ");
        }
      };
      if (type.body.indexOf('.') > -1) {
        found = findTypeByPair(type.body);
        return processArrayType(found.scope, found.type);
      } else {
        arrayType = findType(scope, type.body);
        return processArrayType(scope, arrayType);
      }
      break;
    default:
      return type.type;
    }
  });
  validateExpression = function(scope, type, obj){
    var types, result;
    types = getExpectedTypes(scope, type);
    result = types.map(validateValue(scope, obj));
    switch (false) {
    case !(type.type === 'Discrimination' && result.filter(function(it){
      return it === true;
    }).length > 0):
      return true;
    case result.filter(function(it){
        return it === true;
      }).length !== result.length:
      return true;
    default:
      return result.filter(function(it){
        return it !== true;
      }).join("; ");
    }
  };
  validateType = function(scope, type, obj){
    switch (getType(obj)) {
    case 'Complex':
      return validateComplexType(scope, type, obj);
    default:
      return validateExpression(scope, type, obj);
    }
  };
  validate = function(typename, obj){
    var pair, ref$, scope, name, type;
    pair = (ref$ = typename != null ? typeof typename.split == 'function' ? typename.split('.') : void 8 : void 8) != null
      ? ref$
      : [];
    if (pair.length !== 2) {
      return "Type mask must be 'Scope.Typename'";
    }
    scope = pair[0];
    name = pair[1];
    type = findType(scope, name);
    if (toString$.call(type).slice(8, -1) === 'String') {
      return type;
    }
    return validateType(scope, type, obj);
  };
  validate.registry = registry;
  validate.syntaxCheck = function(){
    var result;
    result = p.map(function(it){
      return "'" + it[0] + "': { " + it[1] + " }";
    })(
    p.filter(function(it){
      return toString$.call(it[1]).slice(8, -1) === 'String';
    })(
    p.objToPairs(
    registry)));
    if (result.length === 0) {
      return true;
    }
    return result.join("; ");
  };
  return validate;
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}