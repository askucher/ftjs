// Generated by LiveScript 1.5.0
var registry, p, compile, getType, toString$ = {}.toString;
registry = require('./registry.js');
p = require('prelude-ls');
compile = function(str){
  var mask;
  mask = str.match("/(.+)/([ig]?)");
  return new RegExp(mask[1], mask[2]);
};
getType = function(obj){
  return (function(){
    switch (toString$.call(obj).slice(8, -1)) {
    case 'Object':
      return 'Complex';
    case 'Undefined':
      return 'Global.Undefined';
    case 'Null':
      return 'Global.Null';
    case 'String':
      return 'RegularExpression';
    case 'Boolean':
      return 'Global.Boolean';
    case 'Number':
      return 'Global.Number';
    case 'Array':
      return 'ArrayType';
    }
  }());
};
module.exports = function(source){
  var modules, findType, lookupType, lookupInvokeFunctionType, lookupDiscriminationType, getExpectedTypes, validateComplexType, validateValue, validateExpression, validateType, validate;
  modules = p.pairsToObj(
  p.map(function(it){
    return [it[0], registry.compile(it[1])];
  })(
  p.objToPairs(
  source)));
  findType = function(scope, typename){
    var bundle_o, type;
    bundle_o = modules[scope];
    if (bundle_o == null) {
      return "Scope '" + scope + "' not found";
    }
    type = bundle_o[typename];
    if (type == null) {
      return "Type '" + typename + "' is not found in scope '" + scope + "'";
    }
    return type;
  };
  lookupType = function(scope, type){
    var found;
    found = findType(scope, type.body);
    return getExpectedTypes(scope, found);
  };
  lookupInvokeFunctionType = function(scope, type){
    var newType;
    newType = {
      type: 'Internal.Extended',
      basetype: findType(scope, type.body[0]),
      extensions: p.tail(
      type.body)
    };
    return [newType];
  };
  lookupDiscriminationType = function(scope, type){
    return p.concat(
    p.map(getExpectedTypes(scope))(
    type.body));
  };
  getExpectedTypes = curry$(function(scope, type){
    switch (type.type) {
    case 'Type':
      return lookupType(scope, type);
    case 'InvokeFunction':
      return lookupInvokeFunctionType(scope, type);
    case 'Discrimination':
      return lookupDiscriminationType(scope, type);
    default:
      return [type];
    }
  });
  validateComplexType = function(scope, type, obj){
    var validate, result;
    validate = function(field){
      var result;
      result = validateType(scope, field.body, obj[field.name]);
      switch (toString$.call(result).slice(8, -1)) {
      case 'String':
        return "'Field " + field.name + "': { " + result + " }";
      default:
        return result;
      }
    };
    result = p.map(validate)(
    type.fields);
    if (result.filter(function(it){
      return it === true;
    }).length === result.length) {
      return true;
    }
    return "{ " + result.filter(function(it){
      return it !== true;
    }).join(", ") + " }";
  };
  validateValue = curry$(function(scope, obj, type){
    var objType, result, ref$, parts, arrayType, items;
    objType = getType(obj);
    switch (type.type) {
    case 'Internal.Extended':
      return validateValue(scope, obj, type.basetype);
    case 'String':
      result = type.body.indexOf(obj) > -1;
      if (result === true) {
        return true;
      }
      return "'" + obj + "' is not '" + type.body + "'";
    case 'RegularExpression':
      result = (ref$ = obj != null ? typeof obj.match == 'function' ? obj.match(compile(type.body)) : void 8 : void 8) != null ? ref$ : null;
      if (result != null) {
        return true;
      }
      return obj + " does not match to regular expression " + type.body;
    case 'ExportType':
      parts = type.body.split('.');
      switch (false) {
      case parts.length === 2:
        return "Export Type " + type.body + " is not valid";
      case parts[0] !== 'Global':
        result = objType === type.body;
        if (result === true) {
          return true;
        }
        return "Type '" + objType + " isnt " + type.body + "'";
      default:
        return validate(type.body, obj);
      }
      break;
    case 'ArrayType':
      if (objType !== 'ArrayType') {
        return "Object Type is not And ArrayType";
      }
      arrayType = findType(scope, type.body);
      switch (toString$.call(arrayType).slice(8, -1)) {
      case 'String':
        return arrayType;
      default:
        items = obj.map(function(it){
          return validateExpression(scope, arrayType, it);
        });
        if (items.length === items.filter(function(it){
          return it === true;
        }).length) {
          return true;
        }
        return items.filter(function(it){
          return it === false;
        }).join("; ");
      }
      break;
    default:
      return type.type;
    }
  });
  validateExpression = function(scope, type, obj){
    var types, result;
    types = getExpectedTypes(scope, type);
    result = types.map(validateValue(scope, obj));
    switch (false) {
    case !(type.type === 'Discrimination' && result.filter(function(it){
      return it === true;
    }).length > 0):
      return true;
    case result.filter(function(it){
        return it === true;
      }).length !== result.length:
      return true;
    default:
      return result.filter(function(it){
        return it !== true;
      }).join("; ");
    }
  };
  validateType = function(scope, type, obj){
    switch (getType(obj)) {
    case 'Complex':
      return validateComplexType(scope, type, obj);
    default:
      return validateExpression(scope, type, obj);
    }
  };
  validate = function(typename, obj){
    var pair, ref$, scope, name, type;
    pair = (ref$ = typename != null ? typeof typename.split == 'function' ? typename.split('.') : void 8 : void 8) != null
      ? ref$
      : [];
    if (pair.length !== 2) {
      return "Type mask must be 'Scope.Typename'";
    }
    scope = pair[0];
    name = pair[1];
    type = findType(scope, name);
    return validateType(scope, type, obj);
  };
  return validate;
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}